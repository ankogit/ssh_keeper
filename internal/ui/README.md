# SSH Keeper - UI System Documentation

## Обзор

SSH Keeper использует современную архитектуру TUI (Terminal User Interface) на базе Go, построенную с использованием библиотек Bubble Tea и Lipgloss. Система спроектирована для создания интуитивно понятного и функционального интерфейса управления SSH подключениями.

## Архитектура

```
internal/ui/
├── screens/           # Экраны приложения
│   ├── base_screen.go
│   ├── app.go
│   ├── main_menu_screen.go
│   ├── connections_screen.go
│   ├── add_connection_screen.go
│   ├── settings_screen.go
│   └── SCREENS_DOCUMENTATION.md
├── components/        # Переиспользуемые компоненты
│   ├── form_manager.go
│   ├── form_field.go
│   ├── bool_field.go
│   ├── connection_item.go
│   ├── field_constants.go
│   └── COMPONENTS_DOCUMENTATION.md
├── styles/           # Система стилей
│   ├── constants.go
│   ├── styles.go
│   └── README.md
└── README.md         # Этот файл
```

## Основные принципы

### 1. Модульность

- Каждый экран независим и может быть легко добавлен или удален
- Компоненты переиспользуются между экранами
- Четкое разделение ответственности

### 2. Консистентность

- Единообразный интерфейс во всех экранах
- Стандартизированные горячие клавиши
- Общая система стилей

### 3. Расширяемость

- Простое добавление новых экранов
- Легкое создание новых компонентов
- Гибкая система навигации

### 4. Производительность

- Эффективная обработка событий
- Минимальные перерисовки
- Оптимизированный рендеринг

## Ключевые технологии

### Bubble Tea

- **Фреймворк** для создания TUI приложений
- **Модель** - состояние приложения
- **Команды** - асинхронные операции
- **Обновления** - реактивная система

### Lipgloss

- **Стилизация** терминального вывода
- **Цвета** - поддержка 256 цветов и true color
- **Макеты** - гибкая система позиционирования
- **Анимации** - плавные переходы

## Система экранов

### Базовый экран (BaseScreen)

- Общая функциональность для всех экранов
- Стандартизированный рендеринг
- Обработка размеров окна
- Базовые горячие клавиши

### Менеджер экранов (ScreenManager)

- Централизованное управление экранами
- Навигация между экранами
- История переходов
- Регистрация экранов

### Специализированные экраны

- **Главное меню** - точка входа в приложение
- **Список подключений** - управление SSH подключениями
- **Добавление подключения** - форма создания новых подключений
- **Настройки** - конфигурация приложения

## Система компонентов

### FormManager

- Центральный менеджер для управления формами
- Навигация между полями
- Валидация данных
- Рендеринг формы

### FormField

- Универсальный компонент поля формы
- Поддержка различных типов полей
- Встроенная валидация
- Условная видимость

### BoolField

- Специализированный компонент для булевых значений
- Визуальное отображение состояния
- Интуитивная навигация

### ConnectionItem

- Элемент списка для отображения подключений
- Компактное представление информации
- Поддержка фильтрации

## Система стилей

### Константы

- Централизованное хранение цветов и размеров
- Легкое изменение темы
- Консистентность стилей

### Готовые стили

- Предопределенные стили для компонентов
- Адаптивные размеры
- Состояния (обычное, фокус, ошибка)

## Навигация

### Горячие клавиши

- **Глобальные** - работают во всех экранах
- **Экранные** - специфичны для конкретного экрана
- **Контекстные** - зависят от текущего состояния

### Переходы

- **Прямые** - переход к конкретному экрану
- **Обратные** - возврат к предыдущему экрану
- **Условные** - в зависимости от состояния

## Обработка событий

### Типы событий

- **Клавиатура** - нажатия клавиш
- **Мышь** - клики и движение
- **Размер окна** - изменение размеров
- **Таймеры** - периодические обновления

### Обработчики

- **Централизованные** - в ScreenManager
- **Делегированные** - в конкретных экранах
- **Каскадные** - от родительского к дочернему

## Расширение системы

### Добавление экрана

1. Создать структуру экрана
2. Реализовать интерфейс Screen
3. Зарегистрировать в ScreenManager
4. Добавить навигацию

### Добавление компонента

1. Создать файл компонента
2. Реализовать методы Update, View, Init
3. Добавить стили если необходимо
4. Интегрировать с существующими компонентами

### Изменение стилей

1. Обновить константы в styles/constants.go
2. Изменить стили в styles/styles.go
3. Обновить компоненты если необходимо

## Примеры использования

### Создание простого экрана

```go
type MyScreen struct {
    *BaseScreen
    // дополнительные поля
}

func NewMyScreen() *MyScreen {
    return &MyScreen{
        BaseScreen: NewBaseScreen("Мой экран"),
    }
}

func (ms *MyScreen) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    // обработка событий
    return ms, nil
}

func (ms *MyScreen) View() string {
    ms.SetContent("Содержимое экрана")
    return ms.BaseScreen.View()
}
```

### Создание формы

```go
formManager := components.NewFormManager()

formManager.AddField(components.FieldConfig{
    Name:        "username",
    Label:       "Имя пользователя",
    Required:    true,
    Width:       50,
    FieldType:   components.FieldTypeText,
})

// Навигация
formManager.NextField()
formManager.PrevField()

// Валидация
if formManager.ValidateAll() {
    values := formManager.GetValues()
    // обработка данных
}
```

## Лучшие практики

### Структура кода

- Разделяйте логику на небольшие методы
- Используйте константы для магических значений
- Документируйте публичные методы
- Следуйте единому стилю кодирования

### Производительность

- Минимизируйте перерисовки
- Используйте эффективные алгоритмы
- Кэшируйте результаты вычислений
- Избегайте избыточных операций

### Пользовательский опыт

- Предоставляйте обратную связь
- Используйте интуитивные горячие клавиши
- Обеспечивайте консистентность
- Обрабатывайте ошибки gracefully

## Отладка

### Логирование

- Используйте fmt.Printf для отладки
- Добавляйте временные сообщения
- Удаляйте отладочный код перед релизом

### Тестирование

- Тестируйте каждый экран отдельно
- Проверяйте все горячие клавиши
- Тестируйте различные размеры окна
- Проверяйте обработку ошибок

## Заключение

UI система SSH Keeper представляет собой современное, гибкое и расширяемое решение для создания TUI приложений. Архитектура позволяет легко добавлять новые функции, сохраняя при этом консистентность и производительность.

Система спроектирована с учетом принципов SOLID и обеспечивает:

- **Single Responsibility** - каждый компонент имеет одну ответственность
- **Open/Closed** - открыта для расширения, закрыта для модификации
- **Liskov Substitution** - компоненты могут заменять друг друга
- **Interface Segregation** - интерфейсы специфичны для клиентов
- **Dependency Inversion** - зависимости от абстракций, а не от конкретных реализаций

Это обеспечивает высокое качество кода, легкую поддержку и возможность дальнейшего развития системы.
